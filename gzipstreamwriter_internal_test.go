package gzipstreamwriter

import (
	"bytes"
	"compress/gzip"
	"errors"
	"hash/crc32"
	"io"
	"slices"
	"sync"
	"testing"
)

var testGzipWriterPool = sync.Pool{
	New: func() interface{} {
		writer := gzip.NewWriter(io.Discard)
		return writer
	},
}

var testGzipReaderPool = sync.Pool{
	New: func() interface{} {
		reader := new(gzip.Reader)
		return reader
	},
}

func TestWrite(t *testing.T) {
	t.Parallel()

	testcases := []struct {
		note  string
		input []byte
	}{
		{
			note:  "nil input",
			input: nil,
		},
		{
			note:  "single byte",
			input: []byte("A"),
		},
		{
			note:  "many repeated bytes",
			input: bytes.Repeat([]byte("A"), 1000),
		},
	}

	for _, tc := range testcases {
		tc := tc // loop var copy. Not needed in Go 1.22+
		t.Run(tc.note, func(t *testing.T) {
			t.Parallel()

			expBuffer := bytes.Buffer{}
			actBuffer := bytes.Buffer{}

			expGzipWriter, ok := testGzipWriterPool.Get().(*gzip.Writer)
			if !ok {
				t.Fatal("Could not get *gzip.Writer instance from the pool.")
			}
			defer expGzipWriter.Close()
			defer testGzipWriterPool.Put(expGzipWriter)
			expGzipWriter.Reset(&expBuffer)
			actGzipWriter := NewGzipStreamWriter(&actBuffer)

			// Write input through both writers, check for errors.
			expWroteBytes, expErr := compressBuffer(t, expGzipWriter, tc.input)
			actWroteBytes, actErr := compressBuffer(t, actGzipWriter, tc.input)

			if expWroteBytes != actWroteBytes {
				t.Fatalf("expected %d bytes written, got %d bytes", expWroteBytes, actWroteBytes)
			}
			if !errors.Is(actErr, expErr) {
				t.Errorf("expected error %v, got %v", expErr, actErr)
			}

			// Compare decompressed contents for equality.
			gzReader, ok := testGzipReaderPool.Get().(*gzip.Reader)
			if !ok {
				t.Fatal("Could not get *gzip.Reader instance from the pool.")
			}
			defer gzReader.Close()
			defer testGzipReaderPool.Put(gzReader)

			var expResult []byte
			var actResult []byte
			var err error
			if expResult, err = decompressGzipBuffer(t, gzReader, &expBuffer); err != nil {
				t.Fatal(err)
			}
			if actResult, err = decompressGzipBuffer(t, gzReader, &actBuffer); err != nil {
				t.Fatal(err)
			}

			if slices.Compare(expResult, actResult) != 0 {
				t.Fatalf("expected %v, got %v", expResult, actResult)
			}
		})
	}
}

func compressBuffer(t *testing.T, gzWriter io.WriteCloser, data []byte) (int, error) {
	t.Helper()
	var n int
	var err error
	if n, err = gzWriter.Write(data); err != nil {
		return n, err
	}
	if err := gzWriter.Close(); err != nil {
		return n, err
	}
	return n, nil
}

func decompressGzipBuffer(t *testing.T, gzReader *gzip.Reader, buffer *bytes.Buffer) ([]byte, error) {
	t.Helper()
	if err := gzReader.Reset(buffer); err != nil {
		return nil, err
	}
	return io.ReadAll(gzReader)
}

func TestStringWrite(t *testing.T) {
	// TODO
	t.Parallel()
	t.Skip("not implemented")
}

// Originally generated by Copilot, and modified to be an actual test.
func FuzzCRC32Combine(f *testing.F) {
	f.Add([]byte{}, []byte{})
	f.Add([]byte{'A'}, []byte{'B'})
	f.Add([]byte{0x12, 0x34, 0x56, 0x78}, []byte{0x9a, 0xbc, 0xde, 0xf0})
	f.Add(bytes.Repeat([]byte{0x12, 0x34, 0x56, 0x78}, 16), bytes.Repeat([]byte{0x9a, 0xbc, 0xde, 0xf0}, 16))

	f.Fuzz(func(t *testing.T, frontBytes []byte, backBytes []byte) {
		frontCRC := crc32.ChecksumIEEE(frontBytes)
		backCRC := crc32.ChecksumIEEE(backBytes)
		expectedCRC := crc32.ChecksumIEEE(append(frontBytes, backBytes...))
		length := len(backBytes)

		if resultCRC := crc32Combine(frontCRC, backCRC, length); resultCRC != expectedCRC {
			t.Errorf("expected CRC: %d, got CRC: %d", expectedCRC, resultCRC)
		}
	})
}
